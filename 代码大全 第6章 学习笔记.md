# 代码大全 第6章 学习笔记

## 抽象数据类型ADT

### 一句话总结

ADT就是使程序中的数据与现实 的实体间对应起来的桥梁。

### 使用ADT好处

1. 封装的好处
   * 有了ADT，只要对外的接口不变，使用方式就不会变。哪怕是换一种编程语言实现，对外部也是无感知的。
   * ADT使你的数据集合在一起而不会让他们分散在整个程序的角角落落，需要修改一个属性，往往只需要修改某个点，而不是整个程序。
   * 仅需要优化一处实现就可以使得所有使用该接口的地方得到优化，而不需要每处都修改。
2. 操作接口代替操作数据
   * 让接口对程序员更友好。一般来说，`setBoldFont()`比`fontSize = 80`要可读的多。
   * 做的越多，错的越多。
   * 使程序的正确性更加显而易见，操作接口比操作数据更加清晰，更加容易看出逻辑。
3. 抽象的好处
   * 将操作ADT与现实对应，而不用在底层实现层面操作它。

### 使用ADT需要注意的地方

1. 将底层数据创建为ADT，而不是使用底层数据类型。（使数据类型带上语义）

2. 将常用的对象创建为ADT（如文件）

3. 将简单的事物创建为ADT

4. 不要让ADT依赖存储介质（数据应该尽量减少环境依赖）

   

### 在非面向对象中如何使用ADT

   1. 使用id区分多份实例

      ```cpp
      typdef struct font{
          // ...
      }font;
      
      int createFont(){
          // 创建一个font，返回ID
      }
      
      void setBoldFont(int fontID){
          // 通过ID操作font
      }
      ```

      

   2. 明确传入要操作的对象

      ```cpp
      typdef struct font{
          // ...
      }font;
      
      void setBoldFont(font* fontID){
          // 直接操作font
      }
      ```

3. 使用隐含实例（不推荐）

   ```cpp
   typdef struct font{
       // ...
   }font;
   
   font g_font;
   
   void setBoldFont(){
       // 操作全局的font
   }
   ```

   

## 接口设计

### 一句话总结

类应该提供且仅提供与自身表示的对应ADT具有的接口。

### 类的接口应该展现一致的抽象层次

```cpp
class StudentsManager{
    public:
    void addStudent(Student s);
    void removeStudent(student s);
    // ...
    student* getData();
};
```

上面的例子中`addStudent`与`removeStudent`接口的抽象层次都在学生管理者这一层面，而`getData`接口显然是在学生的原始数据层面。

### 提供成对的接口

大多数情况下一个操作应该有一个与之对应的操作，如汽车的加速、减速，列表的节点添加、删除，文件的打开、关闭等。

### 在复杂度膨胀的时候选择分割类

如果一个类的部分接口使用一部分成员，另外的接口使用另外一部分成员，则应该考虑将一个类分割为两个类。

### 接口可编程，而不是表达语义

接口由两部分组成，一部分是可编程部分，由数据类型和其他属性构成，而语义则是由注释或者惯用法构成（如接口A应该在接口B之前被调用等）。为了使一个接口不易被误用，应该将接口设计为可编程的，由编译器限制使用。（思考：为什么C++有`assert`了还要加入`static_assert`）

### 修改类时应注意

有时会发现我们的类可能缺少某个功能，或者缺少某个成员。在添加的时候要保持冷静，正如当初设计类那样，先考虑要添加的这个接口或者成员是不是真的属于当前这个ADT。如果不是，那就换一种修改方法。

### 类的内聚与抽象

类的内聚性与抽象往往紧密联系在一起，呈正相关。当发现一个类的内聚性很弱时，不妨考虑一下类的抽象是否合适，或许换一种抽象会更合适。

### 良好的封装

抽象提供一个让你忽略底层细节的模型来管理复杂度，而封装则强行限制你查看这些底层细节。

* 尽量隐藏

  这包括接口与数据。只暴露确实需要的接口，而数据则一点点都不要暴露。如果确实需要访问数据，那么就提供`GetXXX`和`SetXXX`接口。

* 不要把私用的实现放在类的接口中

  ```cpp
  class Student{
      private:
      string name;
      int age;
      
      public:
      string getName();
      void setName(const string& name)
      int getAge();
      void setAge(int age);
  };
  ```

  上面的代码将成员写在接口类中（事实上很多人都是这么写的，包括我 T_T），乍一看没有什么问题，实时上写在接口类中就会诱导用户去查看实现，更有一些“高级”用户会使用指针偏移等这些“骚操作”去访问其中的私有成员，当某一天你的私有数据发生变更时，其影响不亚于修改了接口描述。

  所以一些编程语言会有一些惯用技法，在接口类中仅包含接口以及一个实现类的私有成员：

  ```cpp
  class Student{
      private:
      StudentImpl * impl;
      public:
      string getName();
      void setName(const string& name)
      int getAge();
      void setAge(int age);
  };
  ```

  如此一来，就能做到接口与实现分离。

* 不对类的使用者做出任何假设

  不要试图提示用户“接口A应该在接口B之前调用”、“不要初始化为0，会崩溃”等，因为用户的程序向来都是“野蛮生长”的，你应该在接口中通过编译、链接等手段限制，最后做好入参检查。

* 避免使用友元类

  友元类在大多数情况下都会破坏封装，它会使你同时考虑更多的代码量，更容易出错。

* 时刻考虑ADT

  在给类添加接口或者成员的时候，要时刻考虑这会不会破坏抽象。

* 不要从语义上破坏封装性

  举一个例子：

  ```cpp
  class Rect{
      public:
      Rect();
      Rect(int x, int y, int w, int h);
  };
  ```

  上述`Rect`类，无参的构造函数的行为是什么呢？是初始化一个`0,0,0,0`的`Rect`呢，还是什么也不做，成员的值为随机数呢？显然这从接口上是无法推测的。所以用户会去查看该类相关的文档，如果文档中没有明确知名，那么用户可能就可能会去翻阅源代码……

  一个好的类接口应该在文档中体现这种“语义”关系，而不是需要用户翻阅源码自己找到相关实现。

## 继承与组合

### 一句话总结

当你想自己控制接口时，使用组合，当你想由基类控制接口时，使用继承。

### 组合

* 表达`has a`关系的时候使用组合
* 在万不得已时使用`private`继承来描述`has a`的关系
* 当成员超过7个时，考虑拆分ADT

### 继承

* 表达`is a`的关系。使用前确保确实有这种关系（里氏替换原则），否则优先使用组合。
* 确保只继承需要的部分。
* 对于以下情况，请考虑是否设计是否合理：
  * 覆盖父类函数。父类中的函数被设计成`no-virtual`，说明接口确定，不希望产生多态，而覆盖了该接口的实现，就是违背了设计的初衷。
  * 只有一个实例。可能是将类与对象混为一谈了。
  * 只有一个派生类的基类。为何不合并成一个呢？不要为“将来可能”思考太多。
* 不要让继承层次太深。继承本来是用来控制复杂度的，当时他自身也是复杂度的来源之一。
* 使用多态来替代大量的类型检查
* 让所有的数据都是`private`，而不是`protected`，`protected`与`public`并没有什么本质的差别。如果派生类需要访问基类私有成员，应该由基类提供`protected`的`getter`和`setter`函数。
* 只有在基类正交的时候才可以使用多重继承创建“混合体”

### 成员函数与数据成员

* 更少的成员函数能够避免出错
* 如果不需要某种函数，就应该明确禁止（声明为`private`或者`delete`）
* 减少类调用的子程序和其他类的数量。（避免`A.getB().getC().func()`）
* 尽量减少类见的关系。

### 构造函数

* 在构造函数中初始化所有成员

* 使用`private`构造函数（或者`delete`构造函数）来强制实现单例

* 优先使用深拷贝，除非论证可行才使用浅拷贝，而且浅拷贝应该在文档或者接口中明确指出。

  使用浅拷贝一般都是为了优化性能，但是正如《unix编程艺术》中所说：“过早的优化是万恶之源”，没有必要为一点不确定的性能提升而增加整个系统的复杂度。而且，众所周知，程序员向来不擅长推断导致性能瓶颈的问题代码。

## 为何创建类

### 一句话总结

创建类的目的其实只是为了让数据更容易被操纵。

### 创建类的好处

* 为现实世界建模
* 为抽象的数据建模
* 降低复杂度
* 隔离复杂度
* 隐藏实现细节
* 限制变动的范围
* 隐藏全局数据
* 让参数传递更顺畅
* 代码更易复用
* 位程序族做计划
* 让操作间的相关性更好（高内聚）
* 更易重构

### 避免的类

* 万能类
* 无关紧要的类
* 动词命名的类

## 包

### 一句话总结

包与类就如类与函数，是为类提高更高层的封装。

### 抽象层次

在不同的抽象层次下，概念有所不同：数据、变量+函数、结构体+方法、类、包、项目、解决方案等，不应该被具体的编程语言限制思想，设计是独立于实现存在的。

## 总结

类中所有需要注意的设计点其实都围绕ADT进行的，只需要在做出决策时充分考虑ADT，就能设计出相对可用的类。