# 代码大全 第 24 章 学习笔记

## 重构的理由（为什么重构）

* 代码重复
* 冗长的子程序
  冗长的子程序可以被拆解为几个短小的子程序
* 循环过长或者嵌套过深
  内部的复杂代码常常具备转换位置程序的潜质，这样的修改将有助于对代码的分解，并减少循环的复杂性。
* 类的内聚性太差
  如果看到了某个类大量包揽了许多彼此无关的任务，那么这个类就应该被拆解成很多个类，每个类负责一组有内在相互关联的任务。
* 类的接口不能提供一致的抽象
  代码在开发过程中，很多一开始就有相同抽象层次的类，会逐渐变得混乱，应该时常使用重构的技术整理这一部分。
* 函数的参数太多
  一个函数通常不要使用超过7个参数，如果超过了，考虑将其封装为结构体。
* 类的内部修改往往被局限于某部分
  类的一部分经常变化，而另一部分基本保持不变，考虑将这个类分割为了两部分。
* 变化导致对多个类的相同修改
* 对继承体系的相同修改
* case语句需要做相同的修改
* 同时使用的相关数据并未以类的方式进行组织
  如果经常对一组数据进行操作，考虑将其封装为一个类。
* 成员函数使用其他类的特征比使用自身类的特征还要多
  这种情况通常意味着，这个成员函数应该放在其他类中。
* 过多使用基本数据类型
  基本数据类型缺乏语义，可以考虑将其关联成一个有意义的人类型。
* 某个类无所事事
  应该去掉无所事事的类。
* 一系列传递流浪数据的子程序
  有一些子程序作用仅仅是调用另一个子程序，可以考虑是否可以直接进行调用。
* 中间人对象无事可做
  如果某个类中绝大多数代码只是调用其他类的成员函数，请考虑是否可以把这样的中间人去掉，转而直接调用其他的类。
* 某个类同其他类关系过于紧密
  两个类之间的耦合关系过于紧密，考虑重新设计。
* 子程序命名不恰当
* 数据成员被设置为公用
  所有的成员都应该是私有的，如果需要访问，考虑添加setter和getter函数。
* 某个派生类仅使用了基类的很少一部分成员函数
  这种情况说明这个派生类的创建仅仅是因为基类碰巧有了该类所需要的子程序，而不是出于逻辑上的派生关系，因此应当考虑进行完善的封装。
* 注释并用于解释难懂的代码
  难懂的代码应该应该重新设计，而不是用注释去解释。
* 使用了全局变量
  使用全局变量的时候，应更多的思考是否有必要。
* 在子程序调用前使用了设置代码或在调用后使用了收尾代码
  如果在此程序调动前必须调用一段代码，或者是在调用后必须调用另一段代码，考虑将代码整合在一起。
* 程序中的一些代码似乎是在将来某个时间才会用到
  超前代码通常是画蛇添足。

## 特定的重构（重构什么）

### 数据级重构

* 具名常量代替神秘数值
* 使变量的名字更为清晰，且传递更多信息。
* 将表达式内联化。
* 使用函数代替表达式。
* 引入中间变量
* 用多个单一用途变量代替某个多用途的变量。
* 在局部用途中使用局部变量而不是参数。
* 将基础数据类型转化为类。
* 将一组类型码转换为类或者是枚举类型。
* 将一组类型码转换成一个基类及其相应的派生类。
* 将数组转化为对象。
* 把群集封装起来。
* 使用数据类来代替传统记录，便于统一检查。

### 语句级的重构

* 分解布尔表达式，让布尔表达式变得有语义。
* 将复杂的布尔表达式转换为命名准确的布尔函数。
* 合并条件语句不同部分中的重复代码片段。
* 使用break或者return而不是循环控制变量。
* 在嵌套的if-then-else语句中，一旦知道答案就立即返回，而不是去赋一个返回值。
* 使用多态替代条件语句。（尤其是重复的case语句）
* 创建和使用null对象，而不是去检测空值。

### 子程序级重构

* 提取子程序或者方法。
* 将子程序的代码内联。
* 将冗长的子程序转化成为类。
* 使用简单的算法代替复杂的算法。
* 增加参数。
* 删除参数。
* 将查询操作从修改操作中独立出来。
* 合并相似的子程序，通过参数提升他们的功能。
* 将行为取决于参数的子程序拆分开来。
* 传递整个对象而非成员。
* 传递成员而非整个对象。
* 包装向下转型的操作。

### 类实现的重构

* 将值对象转化为引用对象。
* 将引用对象转化为值对象。
* 用数据初始化替代虚函数。
* 改变成员函数或者是成员数据的位置。
* 将特殊代码提取为派生类。
* 将相似的代码结合起来，放置到基类中。

### 类接口的重构

* 将成员函数放在另一个类中。
* 将一个类变成两个。
* 删除类。
* 去除委托关系。
* 去掉中间人。
* 使用委托代替继承。
* 使用继承代替委托。
* 引入外部的成员函数。
* 引入扩展类。
* 对暴露在外的成员变量进行封装。
* 对于不能修改的类成员，删除相关的setter成员函数。
* 隐藏那些不会在内之外被用到的成员函数。
* 封装不使用的成员函数。
* 合并那些实现非常类似的基类和派生类。

### 系统级重构

* 为无法控制的数据创建明确的索引源。
* 将单向的类联系改为双向的类联系。
* 将双向的类联系改为单向的内联系。
* 使用工厂模式，而不是简单的构造函数。
* 使用异常取代错误处理代码，或者是做相反方向的变换。

## 安全的重构（如何重构）

* 重构的步伐小一些。
* 同一时间只做一项重构，
* 把要做的事情一条条列出来。
* 设置一个停车场，将重构引起的重构列出来。
* 多使用检查点。
* 利用编译器警告信息。
* 重新测试。
* 增加测试用例。
* 检查对代码的修改。
* 根据重构风险级别来调整重构方法。
  
## 不宜重构的情况（什么时候不需要重构）

* 不要把重构当做先写后改的代名词。
* 避免用重构代替重写，

## 重构策略（什么时机进行重构）

* 在增加子程时进行重构。
* 在添加类的时候进行重构。
* 在修补缺陷的时候进行重构。
* 关注容易出错的模块。
* 关注高度复杂的模板。
* 在维护环境下，改善你手中正在处理的代码。
* 定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码移过这条边界。