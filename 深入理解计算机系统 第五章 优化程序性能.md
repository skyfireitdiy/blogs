* 编写高效程序需要注意的点：
    * 选择适当的数据结构
    * 理解优化编译器的能力和局限性
    * 提高并行性
* 优化程序的步骤
    * 消除不必要的步骤，包括不必要的函数调用、内存引用和条件测试
    * 利用处理器的指令并行能力
* 利用代码剖析程序帮助你找到代码中低效率的地方。
* 编译器优化是以不改变程序行为的情况下进行的。
* 在某些情况下，需要阻止编译器执行内联替换：
    * 使用调试器调试代码
    * 使用性能剖析工具评估性能
* 循环展开优化：使用更少的循环次数，每次计算更多的元素。
* calloc函数按照元素大小和数量申请内存。
* 找出循环中会被执行很多次，但是结果不会变的表达式，移动到前面不会重复执行的区域。
* 使用直接数据访问代替过程调用。
* 将结果放在临时变量中，而不是直接写回内存。因为临时变量常常保存在寄存器中，速度更快。
* 超标量处理器在每个时钟周期内执行多个操作，而且是乱序的。
* 分支预测技术：遇到分支时，处理器预测一条分支继续执行，后面判断如果预测正确就继续执行，如果预测错误就放弃已经运行的结果，回到另一条分支。
* cpu中有不同的功能单元，EU（执行单元）拿到指令后，发给不同的功能单元。
* 功能单元性能：
    * 延迟时间：完成运算所需要的总时间
    * 发射时间：连续两个连续同类型运算之间需要的最小时钟周期数。（流水线）
    * 容量：能够执行该运算的功能单元的数量。（多个功能单元）
* 发射时间为为1的功能单元被称为完全流水线化的。
* 功能单元吞吐量：发射时间的倒数。
* 在循坏代码片段中，寄存器分为4类：
    * 只读
    * 只写
    * 局部
    * 循环（读写）
* 将同类功能放在一起，找出关键路径。
* 循环展开：减少循环次数，增加每次循环的计算量。
* 提高并行性
    * 多个累积变量：将一组合并运算分割成多个部分，在最后进行合并，提高程序的并行性。
    * 重新结合变换：A = A + B + C 变为 A = A + (B + C)，可以让B+C并行执行。
* 通常，只有保持能够执行该操作的所有功能单元的流水线都是满的，程序才能达到这个操作的吞吐量界限。对于延迟为L，容量为C的操作而言，这就要求循环展开因子k>= L*C。
* 浮点数加法是不可结合的。所以编译器一般不会对浮点数的运算进行重新结合优化。
* 延迟界限可以通过利用处理器指令并行打破，而吞吐量界限是限制程序性能的最终屏障。
* 发现循环展开和并行地累计在多个值中，是提高程序性能的更可靠的办法。
* 并行性限制因素
    * 寄存器溢出：当程序的并行度超过了可用寄存器的数量，程序就会在内存上开辟空间存储变量，会引起效率降低。
    * 分支预测和预测错误处罚：gcc可以使用条件传送指令，同时计算两个分支的值，避免基于控制的条件转移。
* 对于分支预测：
    * 不要过分关注可预测的分支
    * 书写适合使用条件传送实现的代码
* 高速缓存数据加载不会成为限制性能的关键路径的一部分。
* 优化程序性能的基本策略：
    * 高级设计。避免使用会产生渐进低效率的算法或者编码技术。
    * 基本编码原则。避免限制优化
        * 消除连续的函数调用
        * 消除不必要的内存引用
        * 
    * 低级优化。机构化代码，利用硬件性能
        * 循环展开。
        * 通过利用多个累积变量和重新结合的技术，找到方法提高指令并行。
        * 重写条件操作。使编译器使用条件数据传送。
* 优化的前提是保证行为一致。
* gcc命令行上使用-pg和-Og参数生成可执行文件，执行可执行文件，会输出一个gmon.out作为gprof的输入。
* 使用gprof需要注意：
    * 计时不准确
    * 假设没有执行内联替换
    * 默认情况下，不会显示对库函数的计时，而是累加到调用他们的函数中。
