# 代码大全 第8章 学习笔记

## 输入都是不安全的

一言以蔽之，好的程序应该是可以兼容各种不同的输入的（不管是合理的还是不合理的），好的函数是可以处理各种参数的（不管是有效的还是无效的）

我们无法确定我们的用户是什么人（或者什么东西？）所以我们不能假定我们可以总是得到正确的输入。我们也无法知道谁会调用我们的函数（甚至有些人工智能程序会偷偷的调用你的程序做些事情），所以我们也不总是会得到正确的参数，所以我们需要对各种输入或者参数做出假定，（尽可能）确保考虑到所有的情况。

在防御式编程中，我们用三种办法来防止外部数据破坏我们的程序：

1. 检查所有的外部数据
   这里的外部数据指的是从网路、文件、鼠标、键盘等I/O设备，或者从其他的内存中获取的数据。这些数据都要检查其有效性、合法性。

2. 检查所有输入参数
   这与检查外部数据类似，因为你不知道谁会调用这个子程序。

3. 处理错误的输入数据
   再检查不通过的时候，需要处理这些错误数据，程序崩溃？错误提示？包容错误？这需要在具体的场景中选择不同的策略。

## 断言

断言是在调试阶段发现程序错误的中常用手段。他应该被用在“这不科学”的情况下。换句话说，断言是只有在程序出现bug的时候才应该被触发。

1. 使用错误处理来处理预期可能会发生的情况，而用断言来处理绝对不应该出现的情况。
   举个例子，使用malloc返回的内存，判断其合法性，应该使用错误处理还是使用断言？当然是错误处理，因为malloc确实会返回0，这是可以预期的。我们获取系统剩余内存，对于负数这种情况，我们应该使用错误处理还是使用断言？应该使用断言！因为如果我们如果获取到了负数内存，那一定是程序出bug了。

2. 不要将需要执行的代码放入断言
   断言是使用在调试阶段的，正常条件下，在产品发布版本中，所有的断言都不该被编译，所以我们的断言语句中不应该包含任何有副作用的代码。

3. 使用断言来验证前条件和后条件
   * 前条件：子程序在执行条件时系统应该达到的状态，包括全局变量、来自内部的参数。
   * 后条件：子程序在执行流程之后，系统应该达到的状态。
  前条件是调用方对被调用方应该承担的义务，后条件是被调用方对调用方该负的责任。假设我们需要智能调节水温，使其保持在30~60摄氏度，函数需要知道当前的温度还计算下一刻应该增加或者减少的温度：
  ```cpp
  int calc_temperature(int t) {
      // some code
      assert(ret <= 30 && ret >= -30); // 对调用者负责
      return ret;
  }

  void some_func(){
      // some code
      assert(now_temperature>=30 && now_temperature <= 60); // 对被调用者负责
      calc_temperature(now_temperature)
  }
  ```

4. 对于高建壮性的代码，应该先使用断言，再处理错误
   换句话说，我们需要在调试阶段竟可能多的发现错误和在发布阶段尽可能恢复错误。此时我们需要同时使用两种方法，使用断言帮助我们在调试时尽可能发现错误，在发布代码中，使用错误处理尽可能从错误状态恢复。

## 错误处理

当检测到错误的时候我们需要如何处理呢？有如下一些方法：

1. 返回中立值
   比如我们调用另一个程序获取标准输出结果，并对输出结果做一些分析，如果我们调用子程序失败的时候，我们可以返回空的结果，这样分析程序在分析的时候，也只是会得出空结果，并不会影响下一步流程。（dockershell在调用子进程时使用了这种错误处理方式）

2. 使用下一个正确的数据
   如果我们需要每秒监测cpu利用率，然后实时显示在界面，在监测过程中，我们突然发现有一组数据不合法，此时应该怎么办呢？只需要跳过此数据，等待下一组数据即可。

3. 返回上一个数据
   同样的，我们需要编写一个子程序获取cpu利用率，当我们从系统获取失败的时候，可以尝试返回上一个数据给用户。

4. 返回最接近的合法值
   比如我们在计算百分比的时候，出现了100.5这个数字（可能是多步计算引起的浮点误差），我们可以直接返回100（`if (ret > 100) return 100;`）

5. 记录日志
   通常此方法会结合其他方法一起使用，以告知开发者更多的信息。

6. 返回错误码或者异常
   可以定义一个错误码的集合，给调用者返回一个错误码（但你无法保证调用者是否会忽略此错误码）或者抛出一个不可忽略的异常。

7. 调用错误处理子程序或者对象
   这种方法的优点是可以让所有的错误处理集中起来。缺点是所有的程序都需要知道这个错误处理点并与之紧密耦合。

8. 显式出错信息
   通常对于界面信息或者网页引用程序，获取可以给用户提示出具体的错误。但是这对不怀好意的人来说是一大助力，他们可能会利用错误信息来发现如何更好地攻击你的系统。

9. 在局部处理错误
   不让错误蔓延到调用者，在本地将错误处理完毕，使调用者不知道发生过错误。这种方式存在很大的局限性，因为当你接收到不合法数据的时候，通常你是不知所措的。

10. 关闭程序
    在姓名攸关的程序中，关闭程序往往比程序带着错误状态继续运行要好。

在实际软件设计过程中，我们需要在不同的场景中选择不同的一种或者多种方法组合处理错误。

## 异常

1. 使用异常可以通知程序的其他部分发生了不可忽略的错误。
2. 异常和断言的使用场景类似，都是处理那种罕见甚至永远不该发生的情况。
3. 不应该用异常来推卸责任
   如果一个错误可以在局部处理，就在局部处理掉，不应该使用异常将他传播到上层处理。
4. 不要在构造函数或者析构函数中抛出异常，除非可以在相同的地方捕获处理。
   此条规则可以参考《effective c++》，书中有详细说明（资源泄漏问题）。
5. 保持异常与函数所在抽象层次一致。
   比如你的calc_temperature函数不应该抛出invalid_value异常（太底层），而应该抛出invalid_temperature异常。
6. 在异常中包含导致异常发生的所有信息。
   如果是数组越界导致的异常，异常中就应该包含数组的长度、使用的索引值等信息。
7. 了解库函数可能抛出的异常。
8. 考虑创建一个集中的异常报告机制。
   注意这里是异常报告机制，而不是异常处理机制，通常我们需要一个统一的异常报告（日志打印、电子邮件报告等），而处理异常的方法往往不同。
9. 对异常的使用标准化。
    对特定的项目，应该设计一套专有的异常类型，并为这个类型建立一个标准（哪一类异常可恢复、哪一类需要报告、哪一类需要停止程序运行等）
10. 尽可能不使用异常。
    能用错误处理解决的问题就不要用异常。异常破坏了代码的封装性。

## 隔离程序

在程序中，我们可以将程序中的数据分为外部不可信数据可内部可信数据，对于外部不可信数据，我们可以使用错误处理的方法应对各种可能的错误，而对于内部可信数据，我们可以使用断言或者异常来应对错误（因为我们认为其可信，出现预期外的值一定是出bug了）。



我们可以在外部数据到内部数据中间加一层转换层，所有通过转换层的数据都将接收检查，要么驳回、要么转换为合法数据，然后再传递给内部数据。这样一来，内部就可以减少很多不可预支的数据判断。

## 辅助调试代码

1. 不要将发布版本的限制强加于调试代码中
   调试版本中可能包含很多检查、报告代码，会影响执行效率，那么此时就不要使用发布版本必须达到的性能指标来约束他，毕竟调试版本最主要的任务是发现代码中存在的逻辑漏洞或者编码错误。
2. 尽早引入调试代码
   尽早引入调试代码，和测试启动开发的原因类似。他会让你在整个项目中受益。
3. 采用进攻式编程
   采用进攻式编程是指尽可能让你的程序问题暴露，有以下一些技巧：
   * 确保断言能够使程序停止运行
   * 完全填充分配的内存。（这样可以检测到内存分配错误）
   * 完全填充分配的文件或者流。（可以检测到文件格式错误）
   * 让default分支导致一个严重错误。（这样可以提醒你还有没有处理到的情况）
   * 删除对象前将它填充垃圾数据（可以检测到野指针）
   * 收集错误日志（主要针对已发布的程序）
4. 移除辅助代码
   在程序发布的时候往往需要移除辅助代码（提高性能、压缩体积等），主要有以下方法：
   * 使用构建工具，如使用cmake等工具，控制需要编译哪些代码
   * 使用内置预编译器。（如c++的宏处理器）
   * 自定义预处理器。（使用脚本控制哪些代码参与编译）
   * 使用调试存根（同一个函数，编写调试版本与发布版本）


## 在产品代码中需要保留的防御式代码

1. 保留检查重要错误的代码
   可以在程序遇到重大错误的时候留下一些线索辅助定位排查
2. 删除检查细微错误的代码
   对于能恢复的错误，可以删除其防御式代码（或者改变其工作方式）
3. 去掉可能导致程序硬性崩溃的代码
   对于大多数场景的大多数用户，他们可以忍受程序运行异常（用户可以趁此机会保存数据），但不能忍受程序发生崩溃。（性命攸关的程序例外）
4. 保留可以让程序稳妥崩溃的代码
   对于某些程序，即使崩溃了，用户也不会太在意（如ide的自动完成服务），我们可以在它发生异常的时候记录信息，稳妥退出，然后重新启动即可。
5. 确认留下的信息是友好的
   如果留下的信息不能帮助你精确定位问题，那就删了吧。

## 合理使用防御式编程

防御式编程可以提升系统安全性，但也会导致你的系统变得运行缓慢且臃肿，所以如何把握这个“度”，需要针对不同场景使用不同策略。