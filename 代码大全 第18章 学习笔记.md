# 代码大全 第18章 学习笔记

## 表驱动法的优势

1. 简化控制逻辑
   表驱动法可以替代大量`if else`或者`switch case`的代码逻辑，使代码逻辑更清晰可读。（代码被编写一次，却要被阅读很多次）
2. 提升运行效率
   通常来说，使用`if else`往往都是一条一条匹配，与顺序遍历的逻辑差不多（`switch case`会有一定的优化），而使用表驱动法，其复杂度依赖于表的查询算法，事实上，大多数表的查询都是根据下标在`O(1)`时间复杂度上查找到对应的结果。
3. 更好的扩展性
   使用表驱动可以将数据与数据处理算法分开，这往往带来更好扩展性的收益，在不改变数据处理逻辑的条件下，可以自由调整数据。（C++的STL容器、迭代器、算法也有表驱动的影子）

## 表驱动需要解决的两个问题

1. 怎样从表里查出数据
   有一些数据可能可以通过比较简单的方式建立表索引，比如月份、星期等，还有一种数据，不能直接用来做索引，比如：电话号码、温度等，所以需要一些方法将数据转换为索引：
   * 直接访问
   * 索引访问
   * 阶梯访问
2. 应该在表中存些什么
   对于不同的数据，我们可能会在表中存储对应的处理结果、或者存储处理的方法，通常存储处理方法的表会更复杂。

## 直接访问

对于数据类型为连续整数且最大值不大时，可以使用直接访问的方式建立表，比如人的年龄从`1~120`，日期从`1~31`等。

直接访问方法中，根据表中存储的数据又可以分为以下类：复制信息、键值转换：

### 复制信息

如果我们有一个评分评级规则：

```text
90~100 : A
80~90  : B
70~80  : C
60~70  : D
0~60   : E
```

使用复制信息的方式，我们可能需要建立一个表格：

| 分数  | 级别  |
| :---: | :---: |
|   0   |   E   |
|   1   |   E   |
|   2   |   E   |
|   3   |   E   |
|   4   |   E   |
|  ...  |  ...  |
|  97   |   A   |
|  98   |   A   |
|  99   |   A   |
|  100  |   A   |

这样有一个好处就是：简单粗暴，直接根据成绩查询到评级。缺点就是会有很多冗余信息，浪费了存储空间，所以这种办法在数据量小的时候可以使用。

### 键值转换

使用键值转换可以在牺牲部分性能的条件小减少信息的冗余度，在有大量重复信息的时候比较有用，还是上面的那个例子：

我们使用一个键值转换函数：

```cpp
int convert(int k){
    return k / 10;
}
```

再建立一张表：

| 分数  | 级别  |
| :---: | :---: |
|   0   |   E   |
|   1   |   E   |
|   2   |   E   |
|   3   |   E   |
|   4   |   E   |
|   5   |   E   |
|   6   |   E   |
|   7   |   D   |
|   8   |   C   |
|   9   |   B   |
|  10   |   A   |

这样将原始`key`经过转换函数的转换就可以获取到一个新的`key`，再使用新的`key`访问数据。这种办法在增加了一个转换运算的情况下将存储信息的表大小缩小了10倍。

## 索引访问

有的时候我们索引的范围可能比较大，但是实际有效的数据可能并不多，举个简单的例子，计算机有65536个端口，我们需要根据用户输入的端口号给出该端口的详细描述信息，而大部分端口是没有描述信息的。如果我们使用直接访问的方法，可能就需要65535份描述信息的空间，而大多数存储空间都是浪费的。

我们可以建立两个表，第一个表存储端口到类型（新添加的一个中转索引），第二张表索引到描述信息：

| 端口  | 索引  |
| :---: | :---: |
|   0   |   0   |
|   1   |   0   |
|   2   |   0   |
|  ...  |  ...  |
|  21   |   1   |
|  22   |   2   |
|  23   |   3   |
|  24   |   0   |
|  ...  |  ...  |
|  80   |   4   |
|  81   |   0   |
|  443  |   5   |
|  444  |   0   |
|  ...  |  ...  |


| 索引  | 描述信息   |
| :---: | :--------- |
|   0   | No Message |
|   1   | ftp        |
|   2   | ssh        |
|   3   | telnet     |
|   4   | http       |
|   5   | https      |


给定一个端口，通过第一张表获取到索引，再通过索引在第二张表中查找到数据。这种做法有两种好处：

1. 空间节省
   当描述信息足够大的时候，我们可以存储在“索引 -- 描述信息”中的数据没有冗余，而“端口 -- 索引”表中也只存储了65536个整数索引大小的信息.

2. 更快
   通常使用索引表比直接将数据放在主表中速度更快（数据量更少），而且可以从多个维度来建立索引表（可以参照数据库的索引）

## 阶梯访问

我们回到第一个问题（成绩评级），如果我们的成绩是浮点数，该怎么处理？

我们无法对浮点数建立一一映射的关系（一段区间内的浮点数是无限的）

所以我们可以建立这样一张表：

|  low  | high  | 评级  |
| :---: | :---: | :---: |
|  0.0  | 60.0  |   E   |
| 60.0  | 70.0  |   D   |
| 70.0  | 80.0  |   C   |
| 80.0  | 90.0  |   B   |
| 90.0  | 100.0 |   A   |

在使用过程中，可以通过判断成绩`x`是否`low<=x<high`来判断评级。

使用这种办法需要注意的地方有：

* 端点处理
* 考虑使用二分法查找范围
* 考虑使用索引访问替代（如映射成整数）